// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

contract MedicalRecords is AccessControl {
    using Counters for Counters.Counter;

    bytes32 public constant PATIENT_ROLE = keccak256("PATIENT_ROLE");
    bytes32 public constant DOCTOR_ROLE = keccak256("DOCTOR_ROLE");
    bytes32 public constant RESEARCHER_ROLE = keccak256("RESEARCHER_ROLE");
    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");

    // Data structures (must match interface)
    struct MedicalRecord {
        string ipfsHash;
        address patient;
        uint256 timestamp;
        string fileType;
        uint256 fileSize;
        string description;
    }
    
    struct Consent {
        address grantee;
        uint256 expiresAt;
        uint8 accessLevel;
        bool isActive;
        uint256 grantedAt;
    }
    
    struct AccessRequest {
        uint256 requestId;
        address requester;
        address patient;
        string purpose;
        uint256 duration;
        uint8 accessLevel;
        uint256 timestamp;
        bool isApproved;
        bool isProcessed;
    }
    
    struct EmergencyAccess {
        uint256 emergencyId;
        address responder;
        address patient;
        string reason;
        uint256 timestamp;
        bool approved;
        address[] approvals;
    }
    
    struct ResearchDataset {
        string datasetId;
        string name;
        string description;
        uint256 patientCount;
        string ipfsHash;
        bool active;
    }

    // Storage
    mapping(address => MedicalRecord[]) private patientRecords;
    mapping(address => mapping(address => Consent)) public consents;
    mapping(uint256 => AccessRequest) public accessRequests;
    mapping(uint256 => EmergencyAccess) public emergencyAccesses;
    mapping(string => ResearchDataset) public researchDatasets;
    mapping(address => uint256[]) private patientAccessRequests;
    mapping(address => uint256[]) private doctorAccessRequests;
    mapping(string => bool) public usedHashes;

    Counters.Counter private _requestIdCounter;
    Counters.Counter private _emergencyIdCounter;

    IERC721 public researchToken;
    string[] private datasetIds;

    // Events
    event RecordAdded(address indexed patient, string ipfsHash, uint256 timestamp, string description);
    event ConsentGranted(address indexed patient, address indexed grantee, uint8 accessLevel, uint256 expiresAt);
    event ConsentRevoked(address indexed patient, address indexed grantee);
    event AccessRequested(uint256 indexed requestId, address indexed patient, address requester, string purpose);
    event AccessApproved(uint256 indexed requestId, address indexed patient, address requester);
    event AccessRejected(uint256 indexed requestId, address indexed patient, address requester);
    event EmergencyAccessRequested(uint256 indexed emergencyId, address indexed patient, address responder, string reason);
    event EmergencyAccessGranted(uint256 indexed emergencyId, address indexed patient, address responder);
    event ResearchDatasetAdded(string indexed datasetId, string name, uint256 patientCount);

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _initializeResearchDatasets();
    }

    // ============ ROLE MANAGEMENT ============
    function registerPatient(address patient) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(PATIENT_ROLE, patient);
    }

    function registerDoctor(address doctor) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(DOCTOR_ROLE, doctor);
    }

    function registerResearcher(address researcher) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(RESEARCHER_ROLE, researcher);
    }

    function registerEmergencyResponder(address responder) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(EMERGENCY_ROLE, responder);
    }

    function setResearchToken(address tokenAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        researchToken = IERC721(tokenAddress);
    }

    // ============ MEDICAL RECORDS ============
    function addMedicalRecord(
        string memory ipfsHash, 
        string memory fileType, 
        uint256 fileSize,
        string memory description
    ) external onlyRole(PATIENT_ROLE) {
        require(!usedHashes[ipfsHash], "Duplicate IPFS hash");
        require(bytes(ipfsHash).length > 0, "Invalid IPFS hash");

        MedicalRecord memory newRecord = MedicalRecord({
            ipfsHash: ipfsHash,
            patient: msg.sender,
            timestamp: block.timestamp,
            fileType: fileType,
            fileSize: fileSize,
            description: description
        });

        patientRecords[msg.sender].push(newRecord);
        usedHashes[ipfsHash] = true;

        emit RecordAdded(msg.sender, ipfsHash, block.timestamp, description);
    }

    function getMyRecords() external view returns (MedicalRecord[] memory) {
        return patientRecords[msg.sender];
    }

    function getPatientRecords(address patient) external view returns (MedicalRecord[] memory) {
        require(hasAccess(patient, msg.sender), "No access to patient records");
        return patientRecords[patient];
    }

    // ============ CONSENT MANAGEMENT ============
    function grantConsent(address grantee, uint256 duration, uint8 accessLevel) external onlyRole(PATIENT_ROLE) {
        require(hasRole(DOCTOR_ROLE, grantee) || hasRole(RESEARCHER_ROLE, grantee), "Invalid grantee");
        require(accessLevel == 1 || accessLevel == 2, "Invalid access level");

        consents[msg.sender][grantee] = Consent({
            grantee: grantee,
            expiresAt: block.timestamp + (duration * 1 days),
            accessLevel: accessLevel,
            isActive: true,
            grantedAt: block.timestamp
        });

        emit ConsentGranted(msg.sender, grantee, accessLevel, block.timestamp + (duration * 1 days));
    }

    function revokeConsent(address grantee) external onlyRole(PATIENT_ROLE) {
        consents[msg.sender][grantee].isActive = false;
        emit ConsentRevoked(msg.sender, grantee);
    }

    function getConsentStatus(address patient, address grantee) external view returns (Consent memory) {
        require(msg.sender == patient || msg.sender == grantee || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Access denied");
        return consents[patient][grantee];
    }

    // ============ ACCESS REQUESTS ============
    function requestAccess(address patient, string memory purpose, uint256 duration, uint8 accessLevel) external {
        require(hasRole(DOCTOR_ROLE, msg.sender) || hasRole(RESEARCHER_ROLE, msg.sender), "Not authorized");
        require(hasRole(PATIENT_ROLE, patient), "Invalid patient");
        require(accessLevel == 1 || accessLevel == 2, "Invalid access level");

        _requestIdCounter.increment();
        uint256 requestId = _requestIdCounter.current();

        accessRequests[requestId] = AccessRequest({
            requestId: requestId,
            requester: msg.sender,
            patient: patient,
            purpose: purpose,
            duration: duration,
            accessLevel: accessLevel,
            timestamp: block.timestamp,
            isApproved: false,
            isProcessed: false
        });

        patientAccessRequests[patient].push(requestId);
        doctorAccessRequests[msg.sender].push(requestId);

        emit AccessRequested(requestId, patient, msg.sender, purpose);
    }

    function approveAccess(uint256 requestId) external {
        AccessRequest storage request = accessRequests[requestId];
        require(request.patient == msg.sender, "Not the patient");
        require(!request.isProcessed, "Request already processed");

        request.isApproved = true;
        request.isProcessed = true;

        consents[msg.sender][request.requester] = Consent({
            grantee: request.requester,
            expiresAt: block.timestamp + (request.duration * 1 days),
            accessLevel: request.accessLevel,
            isActive: true,
            grantedAt: block.timestamp
        });

        emit AccessApproved(requestId, msg.sender, request.requester);
    }

    function rejectAccess(uint256 requestId) external {
        AccessRequest storage request = accessRequests[requestId];
        require(request.patient == msg.sender, "Not the patient");
        require(!request.isProcessed, "Request already processed");

        request.isApproved = false;
        request.isProcessed = true;
        emit AccessRejected(requestId, msg.sender, request.requester);
    }

    function getMyAccessRequests() external view returns (uint256[] memory) {
        if (hasRole(PATIENT_ROLE, msg.sender)) {
            return patientAccessRequests[msg.sender];
        } else if (hasRole(DOCTOR_ROLE, msg.sender) || hasRole(RESEARCHER_ROLE, msg.sender)) {
            return doctorAccessRequests[msg.sender];
        }
        revert("Not authorized");
    }

    function getAccessRequest(uint256 requestId) external view returns (AccessRequest memory) {
        AccessRequest memory request = accessRequests[requestId];
        require(
            msg.sender == request.patient || 
            msg.sender == request.requester || 
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Access denied"
        );
        return request;
    }

    // ============ EMERGENCY ACCESS ============
    function requestEmergencyAccess(address patient, string memory reason) external onlyRole(EMERGENCY_ROLE) {
        require(hasRole(PATIENT_ROLE, patient), "Invalid patient");

        _emergencyIdCounter.increment();
        uint256 emergencyId = _emergencyIdCounter.current();

        address[] memory initialApprovals = new address[](0);
        
        emergencyAccesses[emergencyId] = EmergencyAccess({
            emergencyId: emergencyId,
            responder: msg.sender,
            patient: patient,
            reason: reason,
            timestamp: block.timestamp,
            approved: false,
            approvals: initialApprovals
        });

        emit EmergencyAccessRequested(emergencyId, patient, msg.sender, reason);
    }

    function approveEmergencyAccess(uint256 emergencyId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        EmergencyAccess storage emergency = emergencyAccesses[emergencyId];
        require(!emergency.approved, "Already approved");

        // Check for existing approval
        for (uint i = 0; i < emergency.approvals.length; i++) {
            if (emergency.approvals[i] == msg.sender) {
                revert("Already approved by this address");
            }
        }

        // Create new array with additional approval
        address[] memory newApprovals = new address[](emergency.approvals.length + 1);
        for (uint i = 0; i < emergency.approvals.length; i++) {
            newApprovals[i] = emergency.approvals[i];
        }
        newApprovals[emergency.approvals.length] = msg.sender;
        emergency.approvals = newApprovals;

        if (emergency.approvals.length >= 2) {
            emergency.approved = true;

            consents[emergency.patient][emergency.responder] = Consent({
                grantee: emergency.responder,
                expiresAt: block.timestamp + 1 days,
                accessLevel: 1, // View only for emergency
                isActive: true,
                grantedAt: block.timestamp
            });

            emit EmergencyAccessGranted(emergencyId, emergency.patient, emergency.responder);
        }
    }

    function getEmergencyAccess(uint256 emergencyId) external view returns (EmergencyAccess memory) {
        EmergencyAccess memory emergency = emergencyAccesses[emergencyId];
        require(
            msg.sender == emergency.patient || 
            msg.sender == emergency.responder || 
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||
            hasRole(EMERGENCY_ROLE, msg.sender),
            "Access denied"
        );
        return emergency;
    }

    // ============ RESEARCH DATASETS ============
    function _initializeResearchDatasets() private {
        addResearchDataset("diabetes", "Diabetes Study Dataset (2023)", "Comprehensive diabetes patient data", 4231, "QmDiabetesHash");
        addResearchDataset("cardio", "Cardiovascular Health (2022-2023)", "Cardiovascular health metrics", 8742, "QmCardioHash");
        addResearchDataset("cancer", "Oncology Treatment Outcomes", "Cancer treatment and outcome data", 1532, "QmCancerHash");
    }

    function addResearchDataset(
        string memory datasetId,
        string memory name,
        string memory description,
        uint256 patientCount,
        string memory ipfsHash
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        researchDatasets[datasetId] = ResearchDataset({
            datasetId: datasetId,
            name: name,
            description: description,
            patientCount: patientCount,
            ipfsHash: ipfsHash,
            active: true
        });

        datasetIds.push(datasetId);
        emit ResearchDatasetAdded(datasetId, name, patientCount);
    }

    function getResearchDataset(string memory datasetId) external view returns (ResearchDataset memory) {
        require(hasRole(RESEARCHER_ROLE, msg.sender), "Not a researcher");
        require(address(researchToken) != address(0), "Research token not set");
        require(researchToken.balanceOf(msg.sender) > 0, "Research token required");
        require(researchDatasets[datasetId].active, "Dataset not available");

        return researchDatasets[datasetId];
    }

    function getAllDatasets() external view returns (string[] memory) {
        return datasetIds;
    }

    // ============ HELPER FUNCTIONS ============
    function hasAccess(address patient, address requester) public view returns (bool) {
        if (patient == requester) return true;
        if (hasRole(DEFAULT_ADMIN_ROLE, requester)) return true;
        if (hasRole(EMERGENCY_ROLE, requester) && emergencyHasAccess(patient, requester)) return true;

        Consent memory consent = consents[patient][requester];
        return consent.isActive && consent.expiresAt > block.timestamp;
    }

    function emergencyHasAccess(address patient, address responder) private view returns (bool) {
        for (uint256 i = 1; i <= _emergencyIdCounter.current(); i++) {
            EmergencyAccess memory emergency = emergencyAccesses[i];
            if (
                emergency.patient == patient && 
                emergency.responder == responder &&
                emergency.approved &&
                emergency.timestamp + 1 days > block.timestamp
            ) {
                return true;
            }
        }
        return false;
    }

    function getPatientStats(address patient) external view returns (uint256 recordCount, uint256 accessGrants, uint256 pendingRequests) {
        require(msg.sender == patient || hasAccess(patient, msg.sender), "No access");
        recordCount = patientRecords[patient].length;
        pendingRequests = patientAccessRequests[patient].length;
        
        // Calculate active access grants
        uint256 grants = 0;
        // Simplified implementation - in production you'd want to track this differently
        accessGrants = grants;
        
        return (recordCount, accessGrants, pendingRequests);
    }

    function getDoctorStats(address doctor) external view returns (uint256 patients, uint256 accessRequestsCount, uint256 approvedAccess) {
        require(msg.sender == doctor || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "No access");
        accessRequestsCount = doctorAccessRequests[doctor].length;
        
        // Calculate approved access
        uint256 approved = 0;
        for (uint256 i = 0; i < accessRequestsCount; i++) {
            uint256 requestId = doctorAccessRequests[doctor][i];
            if (accessRequests[requestId].isApproved) {
                approved++;
            }
        }
        approvedAccess = approved;
        
        // Patients count would require tracking unique patients
        patients = 0; // Simplified for now
        
        return (patients, accessRequestsCount, approvedAccess);
    }

    // Required override for AccessControl
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}